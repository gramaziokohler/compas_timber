from compas.geometry import Point

from compas_timber.elements import BallNodeFastener
from compas_timber.utils import intersection_line_line_param

from .joint import Joint
from .solver import JointTopology


class BallNodeJoint(Joint):
    """Represents a ball node type joint which joins the ends of multiple beams,
    trimming the main beam.

    Please use `BallNodeJoint.create()` to properly create an instance of this class and associate it with an model.

    Parameters
    ----------
    beams :  list(:class:`~compas_timber.parts.Beam`)
        The beams to be joined.

    Attributes
    ----------
    beams : list(:class:`~compas_timber.parts.Beam`)
        The beams joined by this joint.
    beam_keys : list(str)
        The keys of the beams.
    features : list(:class:`~compas_timber.parts.Feature`)
        The features created by this joint.
    joint_type : str
        A string representation of this joint's type.

    """

    SUPPORTED_TOPOLOGY = JointTopology.TOPO_UNKNOWN
    MAX_ELEMENT_COUNT = None

    def __init__(self, beams=None, timber_interface=None, ball_diameter=100, **kwargs):
        super(BallNodeJoint, self).__init__(**kwargs)
        self.elements = beams
        self.timber_interface = timber_interface
        self.ball_diameter = ball_diameter
        self.beam_keys = [str(beam.guid) for beam in self.beams]
        self.joint_type = "BallNode"
        self._node_point = None
        self.fastener = BallNodeFastener(self.node_point, ball_diameter)
        for beam in self.beams:
            self.fastener.add_interface(beam, timber_interface)

    @property
    def interactions(self):
        for beam in self.beams:
            yield (beam, self.fastener, self)

    @classmethod
    def create(cls, model, *beams, **kwargs):
        """Creates an instance of this joint and creates the new connection in `model`.

        `beams` are expected to have been added to `model` before calling this method.

        This code does not verify that the given beams are adjacent and/or lie in a topology which allows connecting
        them. This is the responsibility of the calling code.

        A `ValueError` is raised if `beams` contains less than two `Beam` objects.

        Parameters
        ----------
        model : :class:`~compas_timber.model.TimberModel`
            The model to which the beams and this joing belong.
        beams : list(:class:`~compas_timber.parts.Beam`)
            A list containing two beams that whould be joined together

        Returns
        -------
        :class:`compas_timber.connections.Joint`
            The instance of the created joint.

        """
        joint = cls(beams, **kwargs)
        model.add_element(joint.fastener)
        for interaction in joint.interactions:
            _ = model.add_interaction(*interaction)
        return joint

    def add_features(self):
        """Adds the features of the joint as generated by `FastenerTimberInterface`s to the timber elements."""
        for interface in self.fastener.interfaces:
            for feature in interface.features:
                interface.element.add_feature(feature)

    @property
    def node_point(self):
        """Returns the point at which the beams are joined, essentially the average of their intersection points."""
        if not self._node_point:
            beams = list(self.beams)
            cpt = Point(0, 0, 0)
            for i, beam in enumerate(beams):
                points = intersection_line_line_param(
                    beams[i - 1].centerline, beam.centerline
                )  # TODO: include Tolerance check here.
                if points[0][0] is not None and points[1][0] is not None:
                    cpt += points[1][0]
            self._node_point = cpt * (1.0 / len(beams))
        return self._node_point
