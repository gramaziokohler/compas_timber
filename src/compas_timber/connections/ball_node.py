from __future__ import annotations

from typing import TYPE_CHECKING

from compas.geometry import Frame
from compas.geometry import Point

from compas_timber.elements import Beam
from compas_timber.fasteners import BallNodeFastener
from compas_timber.utils import intersection_line_line_param

from .joint import Joint
from .solver import JointTopology

if TYPE_CHECKING:
    from compas_timber.fasteners.fastener import Fastener


class BallNodeJoint(Joint):
    """Represents a ball node type joint which joins the ends of multiple beams,
    trimming the main beam.

    Please use `BallNodeJoint.create()` to properly create an instance of this class and associate it with an model.

    Parameters
    ----------
    beams :  list(:class:`~compas_timber.elements.Beam`)
        The beams to be joined.
    base_interface : :class:`~compas_timber.connections.FastenerTimberInterface`
        Describes the interface between the fastener and each of the timber elements.
    ball_diameter : float
        The diameter of the ball node.

    Attributes
    ----------
    elements : list(:class:`~compas_timber.elements.Element`)
        The elements joined by this joint.
    generated_elements : list(:class:`~compas_timber.elements.Element`)
        The elements generated by this joint.

    """

    SUPPORTED_TOPOLOGY = JointTopology.TOPO_Y
    MAX_ELEMENT_COUNT = None

    @property
    def __data__(self):
        data = super(BallNodeJoint, self).__data__
        data["beam_guids"] = self._beam_guids
        data["fastener_guid"] = self._fastener_guid
        data["base_interface"] = self.fastener.base_interface
        return data

    def __init__(self, beams: list[Beam], ball_diameter: float = 10, rods_length: float = 30, **kwargs):
        super().__init__(**kwargs)
        self._beam_guids = []
        self.beams = beams or []

        self.base_fastener = BallNodeFastener.from_joint(self, ball_diameter, rods_length)
        self._fasteners = []

        self._beam_guids = kwargs.get("beam_guids", None) or [str(beam.guid) for beam in self.beams]
        self._fastener_guid = kwargs.get("fastener_guid", None)

        self.place_fastener_instances()

    @property
    def generated_elements(self):
        return self.fasteners

    @property
    def elements(self):
        return list(self.beams) + self.generated_elements

    @property
    def fasteners(self) -> list[Fastener]:
        """
        Returns all fasteners of the joint.

        Returns
        -------
        list[:class:`compas_timber.fasteners.Fastener`]
            A list of all fasteners in the joint.
        """
        fasteners = []
        for fastener in self._fasteners:
            fasteners.extend(fastener.find_all_nested_sub_fasteners())
        return fasteners

    @classmethod
    def create(cls, model, *elements, **kwargs):
        """Creates an instance of the BallNodeJoint and creates the new connection in `model`.

        This differs fom the generic `Joint.create()` method in that it passes the `beams` to
        the constructor of the BallNodeJoint as a list instead of as separate arguments.

        `beams` are expected to have been added to `model` before calling this method.

        This code does not verify that the given beams are adjacent and/or lie in a topology which allows connecting
        them. This is the responsibility of the calling code.

        A `ValueError` is raised if `beams` contains less than two `Beam` objects.

        Parameters
        ----------
        model : :class:`~compas_timber.model.TimberModel`
            The model to which the beams and this joing belong.
        elements : list(:class:`~compas_timber.elements.Beam`)
            A list containing beams that whould be joined together

        Returns
        -------
        :class:`compas_timber.connections.Joint`
            The instance of the created joint.

        """
        joint = cls(elements, **kwargs)
        model.add_joint(joint)
        return joint

    @property
    def node_point(self):
        """Returns the point at which the beams are joined, essentially the average of their intersection points."""
        beams = list(self.beams)
        cpt = Point(0, 0, 0)
        count = 0
        for i, beam in enumerate(beams):
            points = intersection_line_line_param(beams[i - 1].centerline, beam.centerline)  # TODO: include Tolerance check here.
            if points[0][0] is not None and points[1][0] is not None:
                cpt += points[1][0]
                count += 1
        self._node_point = cpt * (1.0 / count)
        return self._node_point

    def place_fastener_instances(self):
        target_frame = Frame.worldXY()
        target_frame.point = self.node_point
        fastener_instance = self.base_fastener.compute_joint_instance(target_frame)
        self._fasteners.append(fastener_instance)

    def compute_fasteners_interactions(self) -> list[tuple]:
        """
        Computes the interactions between fasteners and beams and fastener and sub-fastnert participating to the joint.
        """
        interactions = []
        # beam ---- fastener ---- beam
        for fastener in self._fasteners:
            for beam in self.beams:
                interactions.append((beam, fastener))
            # fastener ---- sub_fastener ---- sub-fastener
            interactions.extend(fastener.compute_sub_fasteners_interactions())
        return interactions

    def add_features(self):
        """Adds the features of the joint as generated by `FastenerTimberInterface` to the timber elements.
        In this joint, the fastener adapt to the beams, therefore, the joint creates the FastenerTimberInterface
        and adds it to the fastener.

        """
        for fastener in self.fasteners:
            fastener.apply_processings(self)

    def restore_beams_from_keys(self, model):
        self.beams = [model[guid] for guid in self._beam_guids]
        self.fastener = model[self._fastener_guid]
