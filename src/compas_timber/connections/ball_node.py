from __future__ import annotations

from typing import Optional

from compas.geometry import Frame
from compas.geometry import Plane
from compas.geometry import Point
from compas.geometry import Vector

from compas_timber.elements import Beam
from compas_timber.fasteners import BallNodeFastener2
from compas_timber.fasteners import BallNodeInterface
from compas_timber.fasteners import HoleInterface
from compas_timber.fasteners import Interface
from compas_timber.utils import intersection_line_line_param

from .joint import Joint
from .solver import JointTopology


class BallNodeJoint(Joint):
    """Represents a ball node type joint which joins the ends of multiple beams,
    trimming the main beam.

    Please use `BallNodeJoint.create()` to properly create an instance of this class and associate it with an model.

    Parameters
    ----------
    beams :  list(:class:`~compas_timber.parts.Beam`)
        The beams to be joined.
    base_interface : :class:`~compas_timber.connections.FastenerTimberInterface`
        Describes the interface between the fastener and each of the timber elements.
    ball_diameter : float
        The diameter of the ball node.

    Attributes
    ----------
    elements : list(:class:`~compas_timber.elements.Element`)
        The elements joined by this joint.
    generated_elements : list(:class:`~compas_timber.elements.Element`)
        The elements generated by this joint.

    """

    SUPPORTED_TOPOLOGY = JointTopology.TOPO_Y
    MAX_ELEMENT_COUNT = None

    @property
    def __data__(self):
        data = super(BallNodeJoint, self).__data__
        data["beam_guids"] = self._beam_guids
        data["ball_diameter"] = self.ball_diameter
        data["fastener_guid"] = self._fastener_guid
        data["base_interface"] = self.fastener.base_interface
        return data

    def __init__(self, beams: list[Beam], base_fastener: Optional[BallNodeFastener2] = None, **kwargs):
        super().__init__(**kwargs)
        self._beam_guids = []
        self.beams = beams or []
        self._node_point = None
        self.fasteners = []

        if base_fastener:
            self.base_fastener = base_fastener
        else:
            self.base_fastener = self.create_base_fastener()

        if self.base_fastener:
            self.base_fastener.place_instances(self)

        self._beam_guids = kwargs.get("beam_guids", None) or [str(beam.guid) for beam in self.beams]
        self._fastener_guid = kwargs.get("fastener_guid", None)

    def create_base_fastener(self):
        fastener = BallNodeFastener2(Frame.worldXY(), 10)
        # add the interfaces to the fastener
        for beam in self.beams:
            # Hole Interface
            # direction = Vector.from_start_end(self.node_point, beam.centerline.midpoint)
            # direction.unitize()
            # frame = Frame.from_plane(Plane(self.node_point, direction))
            # frame.point += fastener.ball_radius * direction
            # hole_interface = HoleInterface(frame, 3, 3)
            # fastener.add_interface(hole_interface)

            # BallNodeInterface
            direction = Vector.from_start_end(self.node_point, beam.centerline.midpoint)
            direction.unitize()
            frame = Frame.from_plane(Plane(self.node_point, direction))
            frame.point += fastener.ball_radius * direction
            ball_node_interface = BallNodeInterface(frame, 15)
            fastener.add_interface(ball_node_interface)

        return fastener

    @property
    def generated_elements(self):
        return self.fasteners

    @property
    def elements(self):
        return list(self.beams) + self.generated_elements

    # @property
    # def interactions(self):
    #     for beam in self.beams:
    #         yield (beam, self.fastener)

    @classmethod
    def create(cls, model, *elements, **kwargs):
        """Creates an instance of the BallNodeJoint and creates the new connection in `model`.

        This differs fom the generic `Joint.create()` method in that it passes the `beams` to
        the constructor of the BallNodeJoint as a list instead of as separate arguments.

        `beams` are expected to have been added to `model` before calling this method.

        This code does not verify that the given beams are adjacent and/or lie in a topology which allows connecting
        them. This is the responsibility of the calling code.

        A `ValueError` is raised if `beams` contains less than two `Beam` objects.

        Parameters
        ----------
        model : :class:`~compas_timber.model.TimberModel`
            The model to which the beams and this joing belong.
        elements : list(:class:`~compas_timber.parts.Beam`)
            A list containing beams that whould be joined together

        Returns
        -------
        :class:`compas_timber.connections.Joint`
            The instance of the created joint.

        """
        joint = cls(elements, **kwargs)
        model.add_joint(joint)
        return joint

    @property
    def node_point(self):
        """Returns the point at which the beams are joined, essentially the average of their intersection points."""
        if not self._node_point:
            beams = list(self.beams)
            cpt = Point(0, 0, 0)
            count = 0
            for i, beam in enumerate(beams):
                points = intersection_line_line_param(beams[i - 1].centerline, beam.centerline)  # TODO: include Tolerance check here.
                if points[0][0] is not None and points[1][0] is not None:
                    cpt += points[1][0]
                    count += 1
            self._node_point = cpt * (1.0 / count)
        return self._node_point

    @property
    def fastener_target_frames(self) -> list[Frame]:
        target_frame = Frame(self.node_point, [1, 0, 0], [0, 1, 0])
        return [target_frame]

    def add_features(self):
        """Adds the features of the joint as generated by `FastenerTimberInterface` to the timber elements.
        In this joint, the fastener adapt to the beams, therefore, the joint creates the FastenerTimberInterface
        and adds it to the fastener.

        """
        for fastener in self.fasteners:
            fastener.apply(self)

    def restore_beams_from_keys(self, model):
        self.beams = [model.element_by_guid(guid) for guid in self._beam_guids]
        self.fastener = model.element_by_guid(self._fastener_guid)
